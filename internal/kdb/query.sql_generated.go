// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package kdb

import (
	"context"
)

const createPrincipal = `-- name: CreatePrincipal :one
INSERT INTO principals (
    primary_name,
    instance,
    realm,
    key_bytes,
    kvno
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, primary_name, instance, realm, key_bytes, kvno, created_at
`

type CreatePrincipalParams struct {
	PrimaryName string `db:"primary_name"`
	Instance    string `db:"instance"`
	Realm       string `db:"realm"`
	KeyBytes    []byte `db:"key_bytes"`
	Kvno        int64  `db:"kvno"`
}

// CreatePrincipal
//
//	INSERT INTO principals (
//	    primary_name,
//	    instance,
//	    realm,
//	    key_bytes,
//	    kvno
//	) VALUES (
//	    ?, ?, ?, ?, ?
//	)
//	RETURNING id, primary_name, instance, realm, key_bytes, kvno, created_at
func (q *Queries) CreatePrincipal(ctx context.Context, db DBTX, arg CreatePrincipalParams) (Principal, error) {
	row := db.QueryRowContext(ctx, createPrincipal,
		arg.PrimaryName,
		arg.Instance,
		arg.Realm,
		arg.KeyBytes,
		arg.Kvno,
	)
	var i Principal
	err := row.Scan(
		&i.ID,
		&i.PrimaryName,
		&i.Instance,
		&i.Realm,
		&i.KeyBytes,
		&i.Kvno,
		&i.CreatedAt,
	)
	return i, err
}

const getPrincipal = `-- name: GetPrincipal :one
SELECT key_bytes, kvno
FROM principals
WHERE primary_name = ? AND instance = ? AND realm = ?
LIMIT 1
`

type GetPrincipalParams struct {
	PrimaryName string `db:"primary_name"`
	Instance    string `db:"instance"`
	Realm       string `db:"realm"`
}

type GetPrincipalRow struct {
	KeyBytes []byte `db:"key_bytes"`
	Kvno     int64  `db:"kvno"`
}

// GetPrincipal
//
//	SELECT key_bytes, kvno
//	FROM principals
//	WHERE primary_name = ? AND instance = ? AND realm = ?
//	LIMIT 1
func (q *Queries) GetPrincipal(ctx context.Context, db DBTX, arg GetPrincipalParams) (GetPrincipalRow, error) {
	row := db.QueryRowContext(ctx, getPrincipal, arg.PrimaryName, arg.Instance, arg.Realm)
	var i GetPrincipalRow
	err := row.Scan(&i.KeyBytes, &i.Kvno)
	return i, err
}

const listPrincipals = `-- name: ListPrincipals :many
SELECT primary_name, instance, realm
FROM principals
ORDER BY primary_name, instance
`

type ListPrincipalsRow struct {
	PrimaryName string `db:"primary_name"`
	Instance    string `db:"instance"`
	Realm       string `db:"realm"`
}

// ListPrincipals
//
//	SELECT primary_name, instance, realm
//	FROM principals
//	ORDER BY primary_name, instance
func (q *Queries) ListPrincipals(ctx context.Context, db DBTX) ([]ListPrincipalsRow, error) {
	rows, err := db.QueryContext(ctx, listPrincipals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPrincipalsRow
	for rows.Next() {
		var i ListPrincipalsRow
		if err := rows.Scan(&i.PrimaryName, &i.Instance, &i.Realm); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
