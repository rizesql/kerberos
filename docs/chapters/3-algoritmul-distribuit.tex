\section{Algoritmul Distribuit: Protocolul Kerberos}

Kerberos rezolvă problema autentificării într-o rețea nesigură folosind un \textit{Trusted Third Party} (KDC). Pentru a face protocolul ușor de înțeles, îl putem privi ca pe un sistem de bilete: utilizatorul nu prezintă parola la fiecare serviciu, ci obține un "permis universal" (TGT) pe care îl schimbă ulterior pentru "bilete specifice" de acces.

\subsection{Notații Utilizate}
Pentru descrierea formală, vom folosi următoarele simboluri simplificate, conform lucrării originale \cite{steiner1988kerberos}:

\end{multicols}
\begin{center}
    \begin{tabular}{|c|l|}
        \hline
        \textbf{Simbol} & \textbf{Semnificație}                                             \\
        \hline
        $C, S$          & Clientul (utilizator) și Serverul (serviciul dorit)               \\
        $AS, TGS$       & Componentele KDC: Authentication Server și Ticket-Granting Server \\
        $K_x$           & Cheia secretă a lui $x$ (ex: hash-ul parolei)                     \\
        $\{M\}_K$       & Mesajul $M$ criptat cu cheia $K$                                  \\
        $TGT$           & \textit{Ticket-Granting Ticket} (Permisul universal)              \\
        $T_{Serv}$      & Tichetul de Serviciu (pentru acces final)                         \\
        $Auth$          & Autentificatorul (dovada identității pe loc, conține timestamp)   \\
        \hline
    \end{tabular}
\end{center}
\begin{multicols}{2}

\subsection{Fluxul Protocolului (Cele 3 Faze)}

Protocolul este împărțit în trei etape logice.

\subsubsection{Faza 1: Autentificarea Inițială (Logarea)}
\textbf{Scop:} Clientul vrea să demonstreze cine este, fără a trimite parola prin rețea.
\begin{itemize}
    \item \textbf{Pasul A:} Clientul trimite numele său către AS. Mesajul este în clar (necriptat), deoarece nu conține secrete.
          \[ C \rightarrow AS: \quad \text{"Sunt utilizatorul } C \text{ și vreau să vorbesc cu TGS"} \]

    \item \textbf{Pasul B:} AS verifică dacă $C$ există în baza de date. Dacă da, creează o cheie de sesiune ($K_{Sess}$) și îi trimite clientului două lucruri:
          \begin{enumerate}
              \item Cheia de sesiune, criptată cu parola clientului: \{$K_{Sess}\}_{K_C}$.
              \item TGT-ul, criptat cu cheia secretă a TGS (pe care clientul nu o poate citi): \{$C, K_{Sess}, \text{Valabilitate}\}_{K_{TGS}}$.
          \end{enumerate}

          \textbf{Rezultat:} Doar clientul real își poate decripta pachetul (știind parola) pentru a obține cheia de sesiune. TGT-ul rămâne un "pachet misterios" pe care îl păstrează.
\end{itemize}

\subsubsection{Faza 2: Obținerea Tichetului de Serviciu (TGS Exchange)}
\textbf{Scop:} Clientul are TGT-ul (permisul) și vrea să acceseze un server specific ($S$), de exemplu un Server de Fișiere.

\begin{itemize}
    \item \textbf{Pasul C:} Clientul trimite către TGS permisul (TGT) și un "Autentificator" (dovadă că e posesorul legitim, conținând ora curentă).
          \[ C \rightarrow TGS: \quad S, \quad TGT, \quad \{C, \text{Timestamp}\}_{K_{Sess}} \]

    \item \textbf{Pasul D:} TGS decriptează TGT-ul (fiind criptat cu cheia sa), extrage cheia de sesiune și verifică Autentificatorul. Dacă totul e valid, emite un tichet pentru Serverul $S$:
          \[ TGS \rightarrow C: \quad \{T_{Serviciu}\}_{K_{Sess}} \]
          Unde $T_{Serviciu}$ este criptat cu cheia Serverului $S$.
\end{itemize}

\subsubsection{Faza 3: Accesarea Serviciului (Client-Server Exchange)}
\textbf{Scop:} Clientul prezintă tichetul final serverului.

\begin{itemize}
    \item \textbf{Pasul E:} Clientul trimite tichetul și un nou autentificator către server.
          \[ C \rightarrow S: \quad T_{Serviciu}, \quad \{C, \text{Timestamp}\}_{K_{C,S}} \]

    \item \textbf{Pasul F:} Serverul decriptează tichetul (folosind propria cheie secretă), află cheia de sesiune partajată și verifică timestamp-ul. Dacă diferența de timp este mică (ex: sub 5 minute), accesul este permis.
\end{itemize}

\subsection{De ce este acest sistem sigur?}
\begin{enumerate}
    \item \textbf{Parola nu circulă niciodată:} Ea este folosită doar local pe stația clientului pentru a decripta primul mesaj de la AS.
    \item \textbf{Protecție la Replay:} Datorită Autentificatorului care conține \textit{Timestamp}, un atacator care interceptează pachetele nu le poate refolosi mai târziu, deoarece serverul va respinge cererile cu ora veche.
    \item \textbf{Minimizarea riscului:} Serverul de aplicație nu trebuie să știe parola utilizatorului, ci doar să poată decripta tichetul emis de KDC.
\end{enumerate}

\subsection{Replicarea și Administrarea Datelor}
Pentru a asigura disponibilitatea și toleranța la defecte (fault tolerance), Kerberos nu rulează pe un singur nod, ci folosește o arhitectură distribuită de tip \textbf{Master-Slave} pentru baza de date de credențiale.

\subsubsection{Arhitectura Master-Slave}
Baza de date este replicată pe mai multe servere KDC:
\begin{itemize}
    \item \textbf{Master KDC:} Este singurul nod care permite operații de scriere (adăugare utilizatori, schimbare parole). Acesta gestionează copia autoritativă a bazei de date.
    \item \textbf{Slave KDCs:} Sunt noduri \textit{Read-Only}. Acestea primesc periodic actualizări de la Master. Clientul se poate autentifica la orice Slave disponibil. Dacă Master-ul pică, autentificarea funcționează în continuare prin Slave-uri, dar nu se pot schimba parole.
\end{itemize}

Această separare este crucială pentru performanța sistemului distribuit, deoarece cererile de citire (autentificările frecvente) sunt balansate între multiple replici, în timp ce scrierile (rare) sunt centralizate pentru consistență.

\subsubsection{Serviciul de Administrare (KDBM)}
Modificările asupra bazei de date se fac exclusiv prin protocolul administrativ, gestionat de procesul \texttt{kadmind}. Deoarece baza de date conține cheile secrete ale tuturor utilizatorilor, acest serviciu rulează doar pe nodul Master și necesită o autentificare strictă.